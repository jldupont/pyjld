#!/usr/bin/env python
"""
:mod:`pyjld.system.daemon`
 
This module borrows heavily from python_daemon_ available at Pypi

.. _python_daemon: http://pypi.python.org/pypi/python-daemon/

"""
__author__ = "Jean-Lou Dupont"
__fileid = "$Id: base.py 44 2009-04-06 14:21:24Z jeanlou.dupont $"
__all__ = ['DaemonRunner','DaemonRunnerException',]

import atexit
import errno
import signal
import os
import sys


# Imports from package ``python_daemon`` available on Pypi
# --------------------------------------------------------
try:
    import daemon
except Exception,e:
    print str(e)
    # For the Windows based development environment...
    #  This helps me with the automatic Sphinx doc generation
    computer_name = str(os.environ.get('computername',None))
    if (computer_name != "JLDUPONT"):
        print "Requires `python_daemon` package available through Pypi"
        exit(0)    


# Local imports
from pyjld.system.daemon.helper import PIDFileHelper



class DaemonRunnerException(Exception):
    """
    DaemonRunner Exception base class
    
    Allows for easier customization of error messages.
    Use `duck typing` to inspect the Exception for the 
    :attr:`msg_id` & :attr:`params` attributes.
    
    """
    def __init__(self, message, msg_id=None, params=None):
        Exception.__init__(self, message)
        self.msg_id = msg_id
        self.params = params

    def __str__(self):
        """
        Not really the intended method of use
        """
        return "Message [%s] msg_id[%s] params[%s]" % (self.message, self.msg_id, self.params)

    

class DaemonRunner(object):
    """
    Controller class for a callable running in a separate background process
    
    The principal methods are:
    
    * :meth:`cmd_start`
    * :meth:`cmd_stop`
    
    
    The ``PID lock file`` is derived from ``app.name`` in the following way ::
    
        ${app.pid_directory}/${app.name}.pid
    
    and by default is located in the ``/var/run`` directory; this directory
    can be customized through the ``app.pid_directory`` attribute.
    
    The exceptions generated by this class contain `pseudo-messages` which are
    really meant as `index` to human readable messages. This way, customization
    is easier to handle.
        
    **Exceptions raised**
    
    All exceptions specific to this class are raised with :class:`DaemonRunnerException`
    and the following *message identifiers* are defined:
    
        * error_pidfile_locked
        * error_pidfile_not_locked
        * error_daemon_aborted
        * error_daemon_open
        * error_daemon_terminate_process
        * error_daemon_openfilepath
        * error_application_method_not_found
        
    The parameter ``app`` must be a callable with, as minimum, the following attributes:
    
    * *name*
    * *run()* method
    * *exit()* method
    
    Optional attributes are:
    
    * *before_start()* method
    * *before_run()* method

    The :meth:`exit` is called when the daemon is shutting down eg. it received
    a SIGTERM signal ( called also during the :meth:`cmd_stop` ).

        
    """
    
    # defaults
    # ========
    _default_pid_filepath_prefix = "/var/run"
    
    
    def __init__(self, app):
        #attributes
        self.app = app
        
        self.context = daemon.DaemonContext()
        
        #validations
        #  Don't init anything BEFORE going through
        #  this checkpoint
        self._validateApp()
        
        
        #initialization
        self._configSTDs()
        self._configPIDFile()



    def cmd_start(self):
        """
        Starts the daemon for ``app``
        
        The method :meth:`app.before_start()` is called prior to actually daemonizing;
        the method can abort the process by raising ...
        
        The method :meth:`app.before_start()` need not to exist (a validity check is performed).
        """
        if self.pidfile.is_locked():
            pidfile_path = self.pidfile.path
            
            if PIDFileHelper.pidfile_lock_is_stale(self.pidfile):
                self.pidfile.break_lock()
            else:
                ##EXCEPTION##
                self._raise("PID file already locked", 
                            'error_pidfile_locked', {'path':self.pidfile.path})
             
        
        # BEFORE START
        # ============
        abort = self._tryBeforeStart()
        if abort:
            self._raise("daemon aborted by 'before_start'",
                        'error_daemon_aborted', {'cause':'BeforeStart application method'})   

        # START!!!
        # ========
        try:
            self.context.open()
        except Exception,e:
            ##EXCEPTION##
            self._raise("daemon error whilst opening",
                        'error_daemon_open', {'exc':e})

        # DAEMON
        # ======

        pid = os.getpid()
        self.app.pid = pid
        
        # Before starting...
        abort = self._tryBeforeRun()
        if abort:
            ##EXCEPTION##
            self._raise("daemon aborted by 'before_run'",
                        'error_daemon_aborted', {'cause':'BeforeRun application method'})

        # RUN!!!
        # ======
        atexit.register(self.app.exit)
        self.app.run()

        
    def cmd_stop(self):
        """
        Stops the daemon for (the currently running) ``app`` but not before calling ``app.stop``
        """
        if not self.pidfile.is_locked():
            pidfile_path = self.pidfile.path
            
            ##EXCEPTION##
            self._raise("PID file not locked / not present",
                        'error_pidfile_not_locked', {'path':pidfile_path})


        if PIDFileHelper.pidfile_lock_is_stale(self.pidfile):
            self.pidfile.break_lock()
        else:
            pid = self.pidfile.read_pid()
            try:
                os.kill(pid, signal.SIGTERM)
            except OSError, exc:
                ##EXCEPTION##
                self._raise("daemon termination fault",
                            'error_daemon_terminate_process', {'pid':pid})                
        
    def cmd_restart(self):
        """
        Restarts the daemon for (the currently running) ``app``
        """
        self.cmd_stop()
        self.cmd_start()



    # =========================================================
    # PRIVATE
    # =========================================================
    
    
    
    def _raise(self, message, msg_id, params=None):
        """
        Exception handling helper
        """
        raise DaemonRunnerException(message, msg_id, params)
    
    
    def _tryBeforeStart(self):
        """
        Gives a chance to the application to abort 
        prior to the ``start`` phase
        """
        return self.__tryAppMethod('before_start', '')

    def _tryBeforeRun(self):
        """
        Gives a chance to the application to abort 
        prior to the ``run`` phase        
        """
        return self.__tryAppMethod('before_run', '')
        
    def __tryAppMethod(self, method, msg):
        """
        """
        method = self._secureGetFromApp(method, None)
        
        # Don't abort for nothing
        if method is None:
            return False
        
        if not callable(method):
            self._raise("Application method[%s] not found" % method, 
                        'error_application_method_not_found', {'method':method})
            
        abort = method()
        return abort
    
    
    def _validateApp(self):
        """
        Performs some quick checks on the ``app`` attribute
        """
        # of course `app` must be configured
        #  We shouldn't have to test this here...
        if self.app is None:
            RuntimeError("application must be configured")
        
        # and must be callable
        #  Nor should we have to perform this check either
        if not callable(self.app):
            RuntimeError('application parameter must be a callable')

        def _checkAppAttr(app, attr):
            if not hasattr(app, attr):
                RuntimeError('appplication callable is not compliant')

        # check required parameters
        for attr in ReferenceApp.requiredAttributes():
            _checkAppAttr(self.app, attr)
            

    def _configSTDs(self):
        """
        Configure stdin, stdout, stderr
        """
        stds = {    'stdin':    ('r',  {}), 
                    'stdout':   ('w+', {}),
                    'stderr':   ('w+', {'buffering':0} ) }
        
        # e.g. stdin_path  in `app`
        #  paths = { std: path }
        paths = dict( (std,getattr(self.app, std+'_path', None))
                    for std in stds )
        
        # skips the `None` ones
        handles = self._openStds( paths, stds )

        # configure the DaemonContext
        for var, handle in handles:
            setattr(self.context, var, handle)



    def _openStds(self, paths, stds):
        """
        Opens the files according to the filepaths, returns handles
        """
        # filter out `None` paths
        names = filter(lambda X: paths[X] is not None, paths)
        
        handles = {}
        
        for name in names:
            path   = paths[name]
            access = stds[name](0)
            params = stds[name](1) 
            handle = self._tryOpenStd(name, path, access, params)
            handles[name] = handle
        
        # { name:handle }    
        return handles
        
        
    def _tryOpenStd(self, name, path, access, params):
        """
        Guarded Open File
        """
        try:    handle = open(path, access, **params)
        except: self._raise("Error opening file path[%s]" % path,
                            'error_daemon_openfilepath', {'path':path, 'extra':name})
            
        return handle
        

    def _configPIDFile(self):
        """
        Configures the PID File
        """
        prefix = self._secureGetFromApp('pidfile_pathprefix', 
                                        self._default_pid_filepath_prefix)
        
        # the forward slash / also works under windows
        #  so we can skip os.path.join
        pidfile_path = prefix.rstrip('/') + "/" + self.app.name
        
        self.pidfile = PIDFileHelper.make_pidlockfile(pidfile_path)
        self.context.pidfile = self.pidfile       


    def _secureGetFromApp(self, param, default = None):
        """
        Gets a parameter from the ``app``
        """
        return getattr(self.app, param, default)




# ===============================================================================




class ReferenceApp(object):
    """
    Used as model of an ``app``
    """
    
    _required_attributes = ['name', 'run', 'exit']
    _optional_attributes = ['pidfile_pathprefix',]

    @classmethod
    def requiredAttributes(cls):
        """
        Generates the list of required attributes
        """
        for attr in cls._required_attributes:
            yield attr
            

